package com.lxg.thread;

/**
 * @author lxg
 * @description 多线程介绍类
 * @date 2021/9/13
 *
 * 程序：
 *    是为了完成特定任务、用某种语言编写的一组指令集合，是一段静态的代码（程序是静态的）
 * 进程：
 *    进程是程序的一个执行过程。正在运行的一个程序，进程作为资源分配的单位，在内存中会为每个进程分配不同的内存区域。
 *    （进程是动态的），是一个动的过程，
 *    进程的生命周期：有他自身的产生、存在和消亡的过程。
 * 线程：
 *    进程可以进一步细化为线程，是一个程序内部的执行路径，若一个进程同一时间并行执行多个线程，就是支持多线程。
 *
 * 传统进程：单线程
 * 多线程进程：多个执行路劲并行执行
 *
 * 单核CPU与多核CPU的执行任务：
 +    单核CPU:
 *       CPU在执行的时候，是按照时间片来执行的，一个世间品啊只能执行一个线程，因为时间片特别段，感受到的就是”同时“执行分多个线程，实际
 *       这种多线程是一种假象。
 *    多核CPU：
 *       多个CPU的时候才真正意义上做到多线程同时进行--多线程发挥了最好的效果--真正的同时执行--真正的多线程。
 *
 * 并行和并发：
 *   并行：
 *      多个CPU同时执行多个任务
 *   并发：
 *     一个CPU”同时“执行多个任务（采用时间片切换）
 *
 *---------------------------------------------------------------------------------------------
 * 创建吸纳成的三种方式：
 *    问题：
 *      在学习多线程之前，编写的程序都是单线程吗？
 *     不是：
 *        如在一般程序中有：
 *        main对应的线程、异常处理线程、垃圾收集器线程
 *        PS：异常线程会影响主线程的执行
 *
 *    - 通过setName和getName方法来设置和获取线程的名称
 *    - 通过构造器给线程设置名字
 *
 *    第一种创建线程的方式：
 *          继承Thread类，重写run方法
 *    第二种创建线程方式：
 *         实现Runnable接口，实现run方法
 *
 * 对比第一种和第二种创建线程的方式，无论第一种还是第二种，都需要实现run方法，但是run方法有两个不足之处：
 *   - 没有返回值
 *   - 不能抛出异常
 *
 *    基于以上两种不足，在JDK1.5以后出现了第三种创建线程的方式
 *        - 实现Callable接口
 *    好处：
 *        - 有返回值
 *        - 能抛出异常
 *    缺点：创建线程比较麻烦
 *
 * 注意：
 *   - 在开发过程中，是实现Runnable接口的方式更好
 *   因为：
 *     1 继承THread类的方法有按继承的局限性，因为继承了thread类，就不能继承其他的类了；
 *     2实现Rynnable共享资源的能力会强一些，不需要非得加static来修饰
 *
 * Thread类实现了Runnable接口，第二种方式也是实现Runable
 *
 * -----------------------------------------------------------------------------------------
 * 线程的生命周期：
 *    1.新生状态： Thread1 t = new Thread1();
 *    2.就绪状态：调用start()方法进入就绪状态， t.start(),此状态万事俱备，只欠CPU
 *    3.运行状态：获得CPU资源，执行run()方法，进入运行状态
 *    4.死亡（消亡）状态：
 *         - 程序正常执行结束
 *         - 出现异常
 *         - 调用stop方法 ： 不建议，stop方法已经被废弃了
 *    5.阻塞状态：在运行状态遇见阻塞事件，进入阻塞状态，阻塞事件结束
 *
 *
 * 线程常用的方法：
 *  1.start()方法：启动当前线程，表面上调用start方法，实际上是调用线程里面的run()方法
 *  2.run()方法：线程类，继承Thread类或者实现Runnable接口，都需要重新实现run方法，run方法里面是线程需要执行的内容。
 *  3.currentThread：Thread类中的一个静态方法，用于获取当前正在执行的线程。
 *  4.setName方法:用于设置线程的名字
 *  5.getNmae方法：用于获取线程的名字
 *
 * - 设置优先级：
 *   -- 同由优先级的线程：采取的策略是先到先服务，使用时间片策略
 *   -- 如果优先级别高，被CPU优先使用的概率就高
 *      优先级：从1到10，最低是1，最高是10，普通线程优先级是5
 *
 *  6.Join()方法：当一个线程调用了join方法，这个线程就会先被执行，它执行结束后才能去执行其他的线程
 *    注意：必须先start，再join才有效
 *
 *  7.sleep()方法：使线程进入阻塞状态
 *  8.setDaemon()方法：设置伴随线程
 *  9.stop():停止线程
 *
 * 线程安全问题：
 *  针对前面编写的抢火车票的例子，有以下安全问题：
 *    - 可能出现多个相同的数据
 *    - 可能出现负数的车票
 *    - 多个线程，在争抢资源得过程中，导致共享得资源出现问题，一个线程没有执行完，另一个线程就参与进来了，开始争抢
 *
 *  解决安全问题方式：
 *  - 同步代码块
 *  - 同步方法
 *
 * 线程同步的缺点：
 * 1.对比
 * 线程安全    效率低
 * 线程不安全  效率高
 *
 * 2.可能造成死锁
 * 死锁：
 *  - 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程死锁
 *    出现死锁后，不会出现异常，不会出现提示，只是所有的线程出现阻塞状态，无法继续
 *
 * 解决办法：
 *  减少同步资源的定义，避免同步嵌套
 *
 *线程间通信：
 * - 生产者和消费者问题
 *  假设仓库只能存放一件产品，生产者将生产出来的东西放入仓库，消费者将仓库中的产品取走
 *  如果仓库中没有产品，则生产者将产品放入仓库，否者停止生产并等待，直到仓库中的产品被消费者取走
 *  如果仓库中放有产品，则消费者可以将产品取走，否则停止消费并等待，直到仓库中再次放入产品为止
 *
 * - 代码
 * 商品： 品牌，名字
 * 线程一：生产者
 * 线程二：消费者
 *
 *
 *  */
public class ThreadDemo {
}
